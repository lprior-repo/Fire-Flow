---
name: fire-flow-orchestration
description: Manages Fire-Flow's contract-driven AI code generation using bitter-truth, Kestra, Nushell, OpenCode, Beads, and MCP servers (mem0, Graphiti, Codanna). Use for code generation, validation, orchestration, task tracking, and documentation lookup.
---

# Fire-Flow Agent Operations Guide

## Quick Navigation

- [Core Systems](#core-systems)
- [bitter-truth 4 Laws](#bitter-truth-4-laws)
- [Tool Selection](#tool-selection)
- [MCP Servers](#mcp-servers)
- [Codanna Usage](#codanna-usage)
- [Validation](#validation)
- [Quick Reference](#quick-reference)

## Core Systems

### bitter-truth
**Purpose**: Contract-driven AI code generation with draconian validation.

**Architecture**: Human → Contract → Kestra → OpenCode → Nushell → Validation

**Key Files**:
- Contracts: `bitter-truth/contracts/` - Humans write (Law 3)
- Tools: `bitter-truth/tools/` - AI writes (Law 1)
- Flows: `bitter-truth/kestra/flows/` - Kestra orchestrates (Law 4)
- Laws: `bitter-truth/LAWS.md`
- Architecture: `bitter-truth/ARCHITECTURE.md`

### Kestra
**Purpose**: Workflow orchestration - owns loops, retries, state, decisions.

**Base**: `http://localhost:4201` | **Namespace**: `main`

**Key API**:
```
GET  /api/v1/main/flows/{namespace}/{id}
PUT  /api/v1/main/flows/{namespace}/{id}
POST /api/v1/main/executions/{namespace}/{flowId}
GET  /api/v1/main/executions/{executionId}/logs
```

**Complete OpenAPI Spec**: `docs/kestra-openapi.yaml` (161 endpoints)

**Key Components**: `tools/kestra-ws/` - Rust client for log streaming and execution monitoring

**Documentation**:
- Official docs: `docs/kestra-docs/INDEX.md`
- OpenAPI spec: `docs/kestra-openapi.yaml` - Complete API reference with all 161 endpoints

### OpenCode Multi-Agent System
**Location**: `~/.opencode`

**10 Agents**: senior-code-reviewer, api-designer, backend-developer, golang-pro, gleam-pro, fractal-orchestrator, architect-reviewer, qa-expert, refactoring-specialist, workflow-orchestrator

**Skills**: On-demand loading, including `parallel-arch-review` for 24+ agent coordination

### Beads Task Management
**Purpose**: Graph-aware task tracking with dependency metrics.

**Commands**:
```bash
bv --robot-triage   # Full report
bv --robot-next       # Top recommendation
bv --robot-plan       # Execution plan
bv --robot-insights   # Graph metrics
bv --robot-history    # Bead-to-commit
bv --robot-alerts     # Stale issues, blockers
```

**Graph Metrics**: PageRank, betweenness, HITS, eigenvector, cycles, k-core, critical path

## bitter-truth 4 Laws

### Law 1: No-Human Zone
**Rule**: Humans never write Nushell scripts. AI generates all `.nu` files.

### Law 2: Contract is Law
**Rule**: DataContract validation is draconian. Only safeguard since AI writes all logic.

**Validation Flow**:
1. Generate code from contract
2. Run `datacontract test --server local <contract.yaml>`
3. If passes → Success
4. If fails → Self-heal (retry with feedback)
5. After 5 failures → Fix **prompt**, not code

### Law 3: We Set the Standard
**Rule**: Human defines target. AI figures out how to hit it.

```
Human: "I need X with Y constraints"
        ↓
   [Contract]  ← The standard
        ↓
   [AI Loop]   ← bitter-truth finds path
        ↓
   [Output]    ← Meets standard or fails
```

### Law 4: Orchestrator Runs Everything
**Rule**: Kestra owns execution. Nothing runs outside orchestration.

- No ad-hoc scripts in production
- Every execution tracked, timed, retried
- Kestra is single source of truth

**Full Documentation**: See `bitter-truth/LAWS.md` and `bitter-truth/ARCHITECTURE.md`

## Tool Selection

### When to Use bitter-truth
- Nushell tool generation from contracts
- Contract validation enforcement
- Self-healing workflows (up to 5 attempts)

**Pattern**: Contract → Kestra → AI → Nushell → Validation

### When to Use OpenCode
- Complex code generation requiring specialized knowledge
- Multi-language projects (Go, Rust, Gleam, Nushell)
- Architecture reviews and refactoring
- Testing strategies and QA planning

**Invocation**:
```bash
opencode run -m <model> "<prompt>"
opencode models  # List available models
```

### When to Use Kestra
- Orchestrating multi-step workflows
- Managing retries and error handling
- Parallel task execution
- Scheduled or event-triggered workflows

### When to Use Nushell
- Structured data processing
- Business logic in tools

**Nushell Patterns**: See `docs/files/LANG_NUSHELL.md`

```nu
# Read JSON stdin, write JSON stdout
let input = open --raw /dev/stdin | from json
{ success: true, data: $result } | to json | print
```

## MCP Servers

### mem0 - Long-Term Memory
**Purpose**: Persistent memory for preferences, decisions, solutions.

**Operations**:
```
mem0_add_memories(text="User prefers Gleam's pipe operator")
mem0_search_memory(query="Gleam preferences")
mem0_list_memories()
mem0_delete_memories(memory_ids=["id1"])
```

**When to Use**:
- Session start - Search for project context
- Learn user preferences - Save immediately
- Make architecture decisions - Save with rationale
- Solve bugs - Save problem → solution → prevention
- Task complete - Consolidate learnings

### Graphiti - Knowledge Graph Memory
**Purpose**: Graph-based memory for entity relationships.

**Operations**:
```
graphiti_add_memory(name="Architecture", episode_body='{"components": ["Kestra"]}', source="json")
graphiti_search_nodes(query="Kestra workflow", max_nodes=10)
graphiti_search_memory_facts(query="validation failures", max_facts=10)
graphiti_analyze_impact(symbol_name="format_xml", max_depth=3)
```

**When to Use**:
- Track relationships between components
- Understanding dependency graphs
- Analyzing impact of changes
- Finding related concepts

### Codanna - Code Intelligence
**Purpose**: Codebase search, dependency analysis, semantic code search.

**Current Index**: 117 symbols, 222 relationships, semantic search enabled (AllMiniLML6V2)

**Operations**:
```python
# Search symbols by name
codanna_find_symbol(name="format_xml")
codanna_search_symbols(query="orchestrator", limit=10)

# Semantic search with context
codanna_semantic_search_with_context(query="agent workflow automation", limit=5, lang="rust")

# Search documents
codanna_search_documents(query="Kestra configuration", limit=5)

# Analyze dependencies
codanna_find_callers(function_name="format_xml")
codanna_get_calls(symbol_id=46)
codanna_analyze_impact(symbol_name="ExecutionWatcher", max_depth=3)

# Get index info
codanna_get_index_info()
```

**When to Use**:
- Finding functions/classes that call specific code
- Understanding dependency relationships
- Semantic search for code patterns
- Impact analysis before refactoring

## Codanna Usage

### Finding Code
```python
# Find exact symbol
codanna_find_symbol(name="format_xml")

# Search with fuzzy matching
codanna_search_symbols(query="orchestrator", limit=10)

# Search by intent
codanna_semantic_search_with_context(query="Kestra WebSocket client", limit=5)

# Search language-specific
codanna_search_symbols(query="workflow", lang="rust", limit=10)
```

### Analyzing Dependencies
```python
# What calls this function
codanna_find_callers(function_name="format_xml")

# What this function calls
codanna_get_calls(symbol_id=46)

# All relationships (calls, types, composition)
codanna_analyze_impact(symbol_name="format_xml", max_depth=3)
```

### Understanding Code Structure
```python
# Index info
codanna_get_index_info()
# Returns: symbols, relationships, kinds, semantic search status

# Key Indexed Components
# - tools/kestra-ws/ - Kestra WebSocket client
# - tools/llm-cleaner/ - LLM output cleaning
```

## Validation

### Core Validator (docs/files/CORE.md)
**Prime Directive**: Trust nothing. Verify everything.

**Validation Sequence** (stop at any BLOCKING failure):
```
P1: Parse Request    → Extract requirements checklist
P2: Completeness     → [BLOCKING] No placeholders, stubs, truncation
P3: Requirements     → [BLOCKING] Code does what was asked
P4: Correctness      → Logic, edge cases, error handling
P5: Hallucinations   → [BLOCKING] APIs/methods actually exist
P6: Tests            → If present, verify they're meaningful
P7: Quality          → Non-blocking suggestions
```

**Verdicts**: PASS, NEEDS_WORK, REJECT

### Shortcut Taxonomy (docs/files/SHORTCUTS.md)

| ID Range | Category | Examples |
|----------|----------|----------|
| S001-S007 | Incompleteness | TODO, stubs, truncation |
| S008-S012 | Logic | Happy path only, edge cases ignored |
| S013-S016 | Hallucination | Fake APIs, wrong method names |
| S017-S020 | Requirement Drift | Wrong problem, scope reduction |
| S021-S025 | Pseudo-Tests | Tautologies, mock abuse |
| S026-S030 | Quality | God functions, leaks |

### Language-Specific Validation

**Nushell** (`docs/files/LANG_NUSHELL.md`):
- NU001-NU010: Common shortcuts and hallucinations
- Validation checklist for structured data, interpolation, error handling

**Kestra** (`docs/files/LANG_KESTRA.md`):
- KE001-KE010: Workflow anti-patterns and hallucinations
- Validation checklist for flows, tasks, triggers, templates

## Kestra Best Practices

### Workflow Design
- **Use explicit namespaces** - Hierarchical by domain (e.g., `company.data.orders`)
- **Add descriptions** - Explain purpose in flow metadata
- **Use descriptive IDs** - `extract_orders`, not `task1`, `task2`
- **Timeouts on long tasks** - Prevent hanging workflows
- **Retry external calls** - HTTP, DB, API with exponential backoff
- **Parallel independent tasks** - Use `Parallel` for concurrent execution
- **Handle errors properly** - Add `errors` section for flow-level handling

### Security
- **Never hardcode secrets** - Always use `secret('KEY_NAME')`
- **Sensitive values not in variables** - Store in secret management
- **Least privilege** - Use scoped secrets, not root credentials

### Configuration Management
- **Environment variables via `vars:`** - Reference as `{{ vars.name }}`
- **Secrets via `secret()`** - Never expose in logs or outputs
- **Namespace files** - Use `namespaceFiles.enabled: true` for shared code
- **Container images** - Specify `containerImage` for reproducibility

### Triggers
- **Schedules need timezone** - Always specify `timezone: America/New_York`
- **Flow triggers need conditions** - Filter by namespace, status
- **Avoid polling** - Prefer triggers over scheduled polling

### Output Management
- **Fetch outputs**: Set `fetch: true` or `store: true` when needed
- **Reference outputs**: Use `outputs.taskId.property` format
- **Input files**: Use `inputFiles:` mapping for file passing
- **Output files**: Use `outputFiles:` for artifact creation

## Quick Reference

### bitter-truth Commands
```bash
# Validate contract
datacontract lint bitter-truth/contracts/tools/echo.yaml

# Run tool
echo '{"message": "hello"}' | nu bitter-truth/tools/echo.nu

# Test contract locally
datacontract test --server local bitter-truth/contracts/tools/echo.yaml
```

### Kestra Commands
```bash
# Deploy flow
curl -X PUT --netrc -H "Content-Type: application/x-yaml" \
  --data-binary '@flow.yml' \
  'http://localhost:4201/api/v1/main/flows/bitter/contract-loop'

# Trigger execution
curl -X POST --netrc \
  -F contract="/path/to/contract.yaml" \
  -F task="Create echo tool" \
  'http://localhost:4201/api/v1/main/executions/bitter/contract-loop'

# Monitor with kestra-ws
kestra-ws poll --execution-id {id} --format json
kestra-ws watch --namespace bitter
```

### Nushell Patterns
```nu
# JSON I/O
let input = open --raw /dev/stdin | from json
{ success: true, data: $result } | to json | print

# Structured data (don't parse strings)
ls | get name
ls | where type == "file"

# Error handling
let content = try { open $path } catch {
  error make { msg: $"Failed to open ($path)" }
}

# Optional access
open data.json | get config.setting? | default "fallback"

# String interpolation
let name = "world"
$"hello ($name)"
```

### OpenCode Commands
```bash
opencode run -m <model> "<prompt>"
opencode models
opencode run --print-logs -m <model> "<prompt>"
```

### Beads Commands
```bash
bv --robot-triage   # Mega-command
bv --robot-next       # Top recommendation
bv --robot-plan       # Parallel execution
bv --robot-insights   # Graph metrics
```

### MCP Server Usage
```python
# mem0
mem0_add_memories(text="User prefers Gleam")
mem0_search_memory(query="Gleam preferences")

# Graphiti
graphiti_add_memory(name="Decision", episode_body='{"decision": "Use Kestra"}', source="json")
graphiti_search_nodes(query="Kestra workflow", max_nodes=10)

# Codanna
codanna_search_symbols(query="workflow", limit=10)
codanna_find_callers(function_name="format_xml")
codanna_analyze_impact(symbol_name="ExecutionWatcher")
```

## Complete Codebase Index

### Quick Navigation
```
Fire-Flow/
├── AGENTS.md                    # This file - Agent operations guide
├── CLAUDE.md                    # Claude-specific instructions
│
├── bitter-truth/                # Contract-driven AI code generation
│   ├── LAWS.md                 # The 4 Laws
│   ├── ARCHITECTURE.md         # Kestra/Nushell separation
│   ├── contracts/               # Humans write
│   ├── tools/                  # AI writes (generate.nu, validate.nu, run-tool.nu)
│   ├── kestra/flows/           # Kestra orchestrates
│   └── tests/
│
├── tools/                       # Helper tools
│   ├── kestra-ws/              # Rust WebSocket client for Kestra
│   ├── llm-cleaner/            # Rust LLM output cleaner
│   └── kestra.nu               # Nushell helper
│
├── docs/
│   ├── files/                  # Core documentation
│   │   ├── README.md            # Project overview
│   │   ├── CORE.md              # AI code validator prime directive
│   │   ├── SHORTCUTS.md        # Shortcut taxonomy
│   │   ├── EXAMPLES.md          # Training examples
│   │   ├── ARCHITECTURE.md       # System architecture
│   │   ├── LANG_*.md            # Language-specific validation
│   │   │   ├── LANG_NUSHELL.md
│   │   │   ├── LANG_KESTRA.md
│   │   │   ├── LANG_RUST.md
│   │   │   ├── LANG_GO.md
│   │   │   └── LANG_GLEAM.md
│   │   ├── 01-project-charter.md
│   │   ├── 02-architecture.md
│   │   ├── 03-technical-spec.md
│   │   ├── 04-adrs.md
│   │   ├── 05-implementation-plan.md
│   │   ├── 06-test-strategy.md
│   │   ├── 07-configuration.md
│   │   └── 08-user-guide.md
│   │
│   ├── kestra-docs/            # Official Kestra documentation
│   │   └── INDEX.md           # Full docs index
│   └── kestra-openapi.yaml       # Complete OpenAPI spec (161 endpoints)
│
├── .beads/                      # Beads task management
├── .codanna/                    # Codanna code intelligence
└── .codannaignore              # Files to exclude from indexing
```

### Finding What You Need
**Search Patterns**:
- **bitter-truth contracts**: `bitter-truth/contracts/`
- **Nushell validation**: `docs/files/LANG_NUSHELL.md`
- **Kestra flows**: `bitter-truth/kestra/flows/`
- **Kestra API**: `docs/kestra-openapi.yaml` (161 endpoints)
- **Code patterns**: Use `codanna_semantic_search_with_context()`
- **Dependencies**: Use `codanna_analyze_impact()`
- **Validation rules**: `docs/files/CORE.md`, `SHORTCUTS.md`, `LANG_*.md`

### Codanna Index Status
**Current Index**: 117 symbols, 222 relationships, semantic search enabled
**Key Indexed Components**:
- `tools/kestra-ws/src/lib.rs` - Kestra WebSocket client
- `tools/llm-cleaner/src/main.rs` - LLM output cleaning
- `bitter-truth/tools/*.nu` - Nushell tools

**Search with**:
```python
# By intent (semantic)
codanna_semantic_search_with_context(query="Kestra workflow automation", limit=5)

# By symbol name
codanna_find_symbol(name="format_xml")
codanna_search_symbols(query="orchestrator", limit=10)

# By relationships
codanna_find_callers(function_name="format_xml")
codanna_analyze_impact(symbol_name="ExecutionWatcher", max_depth=3)
```

## Documentation Index

**Complete navigation** and file locations: See [Complete Codebase Index](#complete-codebase-index)

### Core Guides (`docs/files/`)
- `README.md` - Project overview
- `CORE.md` - AI code validator prime directive
- `SHORTCUTS.md` - Shortcut taxonomy for AI validation
- `ARCHITECTURE.md` (or `02-architecture.md`) - System architecture
- `EXAMPLES.md` - Training examples

### Language-Specific (`docs/files/LANG_*.md`)
- `LANG_NUSHELL.md` - Nushell validation rules
- `LANG_KESTRA.md` - Kestra workflow validation
- `LANG_RUST.md` - Rust code validation
- `LANG_GO.md` - Go code validation
- `LANG_GLEAM.md` - Gleam/BEAM code validation

### Project Planning (`docs/files/0*-*.md`)
- `01-project-charter.md` - Project goals and scope
- `02-architecture.md` - System architecture
- `03-technical-spec.md` - Technical specifications
- `04-adrs.md` - Architecture Decision Records
- `05-implementation-plan.md` - Implementation phases
- `06-test-strategy.md` - Testing approach
- `07-configuration.md` - Configuration management
- `08-user-guide.md` - User documentation

### bitter-truth
- `bitter-truth/LAWS.md` - The 4 Laws
- `bitter-truth/ARCHITECTURE.md` - Kestra/Nushell separation

### Kestra
- `docs/kestra-docs/INDEX.md` - Full documentation index
- `docs/kestra-openapi.yaml` - **Complete OpenAPI spec (161 endpoints)**

**OpenAPI Best Practices**:
- Full specification of all 161 endpoints
- Request/response schemas for each endpoint
- Task types, triggers, and workflow components
- Complete reference for building Kestra clients

## Troubleshooting

### bitter-truth Issues
**Validation fails repeatedly**:
1. Check contract schema - does it match expected output?
2. Fix the **prompt**, not the code (Law 2)
3. After 5 failures, escalate to human

**Timeout during generation**:
1. Check `timeout_seconds` context parameter
2. Verify model is responding: `opencode models`

### Kestra Issues
**Flow won't deploy**:
1. Check YAML syntax
2. Verify credentials in `~/.netrc`

**Execution stuck in RUNNING**:
1. Check execution logs
2. Verify timeout settings
3. Check for hanging processes

### Codanna Issues
**Search returns no results**:
1. Check index info: `codanna_get_index_info()`
2. Try different search terms
3. Check language filter

## Best Practices

### bitter-truth
1. Write clear contracts with specific inputs, outputs, validation rules
2. Use dry-run mode first: `dry_run: true`
3. Review self-healing feedback
4. Follow 4 Laws - never manually edit Nushell
5. Monitor executions with Kestra UI or `kestra-ws`

### Kestra
1. Use secrets: `secret('KEY')` - never hardcode
2. Add timeouts on long-running tasks
3. Configure retries for external calls
4. Use Parallel for independent tasks
5. Handle errors with `errors` section

### Nushell
1. Use structured data operations, not string parsing
2. Add type annotations to custom commands
3. Use `try`/`catch` around fallible operations
4. Use optional access `?` for potentially missing fields
5. Log structured JSON for debugging

### Agent Coordination
1. Use appropriate tools: bitter-truth for Nushell, OpenCode for complex tasks
2. Save to memory (mem0) for preferences and decisions
3. Search first (Codanna) to find existing code patterns
4. Track with Beads: `bv --robot-triage`
5. Validate output using CORE.md checklist
