# Contract Loop Flow - Self-healing code generation
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes code, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Windmill owns execution
#
# PATTERN: Generate -> Execute -> Validate -> (Pass=Exit | Fail=Feedback->Retry)

summary: Contract-driven code generation with self-healing
description: |
  Generates code from a DataContract, executes it, validates output,
  and retries with feedback on failure. Escalates after max attempts.

schema:
  $schema: "https://json-schema.org/draft/2020-12/schema"
  type: object
  required:
    - contract_path
    - task
  properties:
    contract_path:
      type: string
      description: Path to DataContract YAML file
    task:
      type: string
      description: Natural language task description
    language:
      type: string
      default: rust
      enum: [rust, python, typescript, go]
      description: Target language for generation
    input_json:
      type: object
      default: {}
      description: JSON input for the generated code
    max_attempts:
      type: integer
      default: 5
      description: Maximum retry attempts before escalation
    model:
      type: string
      default: anthropic/claude-sonnet-4-20250514
      description: LLM model for generation
    dry_run:
      type: boolean
      default: false
      description: Skip actual generation/execution (for testing)

value:
  modules:
    # Initialize workspace
    - id: init
      value:
        type: rawscript
        language: deno
        content: |
          export async function main() {
            const traceId = crypto.randomUUID().slice(0, 8);
            const workDir = `/tmp/fire-flow-${traceId}`;
            await Deno.mkdir(workDir, { recursive: true });

            return {
              trace_id: traceId,
              work_dir: workDir,
              attempt: 0,
              feedback: "Initial generation"
            };
          }

    # Main retry loop (using Windmill's for-loop)
    - id: retry_loop
      value:
        type: forloopflow
        iterator:
          type: javascript
          expr: "Array.from({length: flow_input.max_attempts}, (_, i) => i + 1)"
        skip_failures: true
        modules:
          # Generate code
          - id: generate
            value:
              type: script
              path: f/fire-flow/generate/script
              input_transforms:
                contract_path:
                  type: javascript
                  expr: flow_input.contract_path
                task:
                  type: javascript
                  expr: flow_input.task
                language:
                  type: javascript
                  expr: flow_input.language
                feedback:
                  type: javascript
                  expr: results.init?.feedback || "Initial generation"
                attempt:
                  type: javascript
                  expr: "`${iter.value}/${flow_input.max_attempts}`"
                output_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/generated_code.${flow_input.language === 'typescript' ? 'ts' : flow_input.language === 'python' ? 'py' : flow_input.language}`"
                model:
                  type: javascript
                  expr: flow_input.model
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Gate 1: Syntax Check (Parse + Lint + Type)
          - id: gate1
            value:
              type: script
              path: f/fire-flow/gate1/script
              input_transforms:
                code_path:
                  type: javascript
                  expr: results.generate.output_path
                language:
                  type: javascript
                  expr: flow_input.language
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Check Gate 1 result - skip to feedback if failed
          - id: check_gate1
            value:
              type: rawscript
              language: deno
              content: |
                export function main(passed: boolean, errors: string[]) {
                  if (passed) {
                    return { status: "passed", errors: [] };
                  }
                  return { status: "failed", errors };
                }
              input_transforms:
                passed:
                  type: javascript
                  expr: results.gate1.passed
                errors:
                  type: javascript
                  expr: results.gate1.errors || []
            stop_after_if:
              expr: "result.status === 'failed'"
              skip_if_stopped: false

          # Execute generated code
          - id: execute
            value:
              type: script
              path: f/fire-flow/execute/script
              input_transforms:
                code_path:
                  type: javascript
                  expr: results.generate.output_path
                language:
                  type: javascript
                  expr: flow_input.language
                code_input:
                  type: javascript
                  expr: flow_input.input_json
                output_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/output.json`"
                logs_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/logs.txt`"
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Validate output
          - id: validate
            value:
              type: script
              path: f/fire-flow/validate/script
              input_transforms:
                contract_path:
                  type: javascript
                  expr: flow_input.contract_path
                output_path:
                  type: javascript
                  expr: results.execute.output_path
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Check if valid - break loop on success
          - id: check_valid
            value:
              type: rawscript
              language: deno
              content: |
                export function main(valid: boolean, iter_value: number, output_path: string) {
                  if (valid) {
                    // Success! Return and stop the loop
                    return {
                      status: "success",
                      attempts: iter_value,
                      output_path: output_path
                    };
                  }
                  // Not valid, continue to feedback
                  return { status: "retry_needed", attempts: iter_value };
                }
              input_transforms:
                valid:
                  type: javascript
                  expr: results.validate.valid
                iter_value:
                  type: javascript
                  expr: iter.value
                output_path:
                  type: javascript
                  expr: results.execute.output_path
            stop_after_if:
              expr: "result.status === 'success'"
              skip_if_stopped: false

          # Collect feedback for retry
          - id: feedback
            value:
              type: script
              path: f/fire-flow/collect_feedback/script
              input_transforms:
                output_path:
                  type: javascript
                  expr: results.execute?.output_path || ""
                logs_path:
                  type: javascript
                  expr: results.execute?.logs_path || ""
                validation_errors:
                  type: javascript
                  expr: results.validate?.errors || results.check_gate1?.errors || []
                gate1_errors:
                  type: javascript
                  expr: results.gate1?.errors || []
                attempt:
                  type: javascript
                  expr: "`${iter.value}/${flow_input.max_attempts}`"
                max_attempts:
                  type: javascript
                  expr: flow_input.max_attempts

          # Update state for next iteration
          - id: update_state
            value:
              type: rawscript
              language: deno
              content: |
                export function main(feedback: string, iter_value: number) {
                  // Return updated state for next iteration
                  return {
                    updated: true,
                    feedback: feedback,
                    attempt: iter_value
                  };
                }
              input_transforms:
                feedback:
                  type: javascript
                  expr: results.feedback.feedback
                iter_value:
                  type: javascript
                  expr: iter.value

    # Final result (after loop completes or breaks)
    - id: final_result
      value:
        type: rawscript
        language: deno
        content: |
          export function main(loop_result: any[], max_attempts: number) {
            // Check if we succeeded
            if (Array.isArray(loop_result) && loop_result.length > 0) {
              const last = loop_result[loop_result.length - 1];
              if (last?.check_valid?.status === "success") {
                return {
                  status: "success",
                  attempts: last.check_valid.attempts,
                  output_path: last.check_valid.output_path,
                  message: "Contract satisfied!"
                };
              }
            }

            // Escalation - max attempts exceeded
            return {
              status: "escalated",
              attempts: max_attempts,
              message: "AI failed to satisfy contract. FIX THE PROMPT OR CONTRACT, NOT THE CODE."
            };
          }
        input_transforms:
          loop_result:
            type: javascript
            expr: results.retry_loop || []
          max_attempts:
            type: javascript
            expr: flow_input.max_attempts
