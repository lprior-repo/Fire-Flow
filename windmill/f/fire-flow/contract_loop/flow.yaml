# Contract Loop Flow - Self-healing code generation
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes code, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Windmill owns execution
#
# PATTERN: Generate -> Execute -> Validate -> (Pass=Exit | Fail=Feedback->Retry)

summary: Contract-driven code generation with self-healing
description: |
  Generates code from a DataContract, executes it, validates output,
  and retries with feedback on failure. Escalates after max attempts.

schema:
  $schema: "https://json-schema.org/draft/2020-12/schema"
  type: object
  required:
    - contract_path
    - task
  properties:
    contract_path:
      type: string
      description: Path to DataContract YAML file
    task:
      type: string
      description: Natural language task description
    language:
      type: string
      default: rust
      enum: [rust, python, typescript, go]
      description: Target language for generation
    input_json:
      type: object
      default: {}
      description: JSON input for the generated code
    max_attempts:
      type: integer
      default: 5
      description: Maximum retry attempts before escalation
    model:
      type: string
      default: anthropic/claude-sonnet-4-20250514
      description: LLM model for generation
    dry_run:
      type: boolean
      default: false
      description: Skip actual generation/execution (for testing)

value:
  modules:
    # Initialize workspace
    - id: init
      value:
        type: rawscript
        language: python3
        content: |
          import uuid
          import os

          def main():
              trace_id = str(uuid.uuid4())[:8]
              work_dir = f"/tmp/fire-flow-{trace_id}"
              os.makedirs(work_dir, exist_ok=True)

              return {
                  "trace_id": trace_id,
                  "work_dir": work_dir,
                  "attempt": 0,
                  "feedback": "Initial generation"
              }

    # Main retry loop (using Windmill's for-loop)
    - id: retry_loop
      value:
        type: forloopflow
        iterator:
          type: javascript
          expr: "Array.from({length: flow_input.max_attempts}, (_, i) => i + 1)"
        skip_failures: true
        modules:
          # Generate code
          - id: generate
            value:
              type: script
              path: f/fire-flow/generate/script
              input_transforms:
                contract_path:
                  type: javascript
                  expr: flow_input.contract_path
                task:
                  type: javascript
                  expr: flow_input.task
                language:
                  type: javascript
                  expr: flow_input.language
                feedback:
                  type: javascript
                  expr: results.init?.feedback || "Initial generation"
                attempt:
                  type: javascript
                  expr: "`${iter.value}/${flow_input.max_attempts}`"
                output_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/generated_code.${flow_input.language === 'typescript' ? 'ts' : flow_input.language === 'python' ? 'py' : flow_input.language}`"
                model:
                  type: javascript
                  expr: flow_input.model
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Execute generated code
          - id: execute
            value:
              type: script
              path: f/fire-flow/execute/script
              input_transforms:
                code_path:
                  type: javascript
                  expr: results.generate.output_path
                language:
                  type: javascript
                  expr: flow_input.language
                code_input:
                  type: javascript
                  expr: flow_input.input_json
                output_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/output.json`"
                logs_path:
                  type: javascript
                  expr: "`${results.init.work_dir}/logs.txt`"
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Validate output
          - id: validate
            value:
              type: script
              path: f/fire-flow/validate/script
              input_transforms:
                contract_path:
                  type: javascript
                  expr: flow_input.contract_path
                output_path:
                  type: javascript
                  expr: results.execute.output_path
                dry_run:
                  type: javascript
                  expr: flow_input.dry_run
                trace_id:
                  type: javascript
                  expr: results.init.trace_id

          # Check if valid - break loop on success
          - id: check_valid
            value:
              type: rawscript
              language: python3
              content: |
                def main(valid: bool, iter_value: int, output_path: str):
                    if valid:
                        # Success! Return and stop the loop
                        return {
                            "status": "success",
                            "attempts": iter_value,
                            "output_path": output_path
                        }
                    # Not valid, continue to feedback
                    return {"status": "retry_needed", "attempts": iter_value}
              input_transforms:
                valid:
                  type: javascript
                  expr: results.validate.valid
                iter_value:
                  type: javascript
                  expr: iter.value
                output_path:
                  type: javascript
                  expr: results.execute.output_path
            stop_after_if:
              expr: "result.status === 'success'"
              skip_if_stopped: false

          # Collect feedback for retry
          - id: feedback
            value:
              type: script
              path: f/fire-flow/collect_feedback/script
              input_transforms:
                output_path:
                  type: javascript
                  expr: results.execute.output_path
                logs_path:
                  type: javascript
                  expr: results.execute.logs_path
                validation_errors:
                  type: javascript
                  expr: results.validate.errors
                attempt:
                  type: javascript
                  expr: "`${iter.value}/${flow_input.max_attempts}`"
                max_attempts:
                  type: javascript
                  expr: flow_input.max_attempts

          # Update state for next iteration
          - id: update_state
            value:
              type: rawscript
              language: python3
              content: |
                def main(feedback: str, iter_value: int):
                    # Return updated state for next iteration
                    return {
                        "updated": True,
                        "feedback": feedback,
                        "attempt": iter_value
                    }
              input_transforms:
                feedback:
                  type: javascript
                  expr: results.feedback.feedback
                iter_value:
                  type: javascript
                  expr: iter.value

    # Final result (after loop completes or breaks)
    - id: final_result
      value:
        type: rawscript
        language: python3
        content: |
          def main(loop_result, max_attempts: int):
              # Check if we succeeded
              if isinstance(loop_result, list) and len(loop_result) > 0:
                  last = loop_result[-1]
                  if last.get("check_valid", {}).get("status") == "success":
                      return {
                          "status": "success",
                          "attempts": last["check_valid"]["attempts"],
                          "output_path": last["check_valid"]["output_path"],
                          "message": "Contract satisfied!"
                      }

              # Escalation - max attempts exceeded
              return {
                  "status": "escalated",
                  "attempts": max_attempts,
                  "message": "AI failed to satisfy contract. FIX THE PROMPT OR CONTRACT, NOT THE CODE."
              }
        input_transforms:
          loop_result:
            type: javascript
            expr: results.retry_loop || []
          max_attempts:
            type: javascript
            expr: flow_input.max_attempts
