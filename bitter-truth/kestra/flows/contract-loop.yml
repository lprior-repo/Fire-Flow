# bitter-truth: Contract-Driven Loop with Self-Healing
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes all Nushell, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Kestra owns execution
#
# THE PATTERN:
# Generate -> Gate -> Pass or Self-Heal -> Escalate after N failures
#
# REQUIREMENTS:
# - nushell (nu) installed and in PATH
# - datacontract-cli installed
# - opencode CLI for AI generation

id: contract-loop
namespace: bitter

inputs:
  - id: contract
    type: STRING
    description: Path to DataContract (source of truth)

  - id: task
    type: STRING
    description: Natural language intent (what AI should generate)

  - id: input_json
    type: STRING
    defaults: "{}"
    description: JSON input for the generated tool

  - id: max_attempts
    type: INT
    defaults: 5
    description: Attempts before escalating to human (to fix PROMPT, not code)

  - id: tools_dir
    type: STRING
    defaults: "./bitter-truth/tools"
    description: Directory containing bitter-truth tools

variables:
  feedback: "Initial generation"

tasks:
  # LOOP: Generate -> Validate -> Self-Heal or Escalate
  - id: loop
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ range(1, inputs.max_attempts + 1) }}"
    tasks:

      # 1. AI GENERATES NUSHELL (Law 1: AI is exclusive author)
      - id: generate
        type: io.kestra.plugin.scripts.shell.Commands
        description: AI compiles intent -> Nushell
        runner: PROCESS
        commands:
          - |
            nu -c '
            let contract_content = (open "{{ inputs.contract }}")
            let prompt = $"TASK: {{ inputs.task }}

            CONTRACT (Law 2 - this is GOD):
            ($contract_content)

            PREVIOUS FEEDBACK:
            {{ vars.feedback }}

            ATTEMPT: {{ taskrun.value }}/{{ inputs.max_attempts }}

            Generate a Nushell script that:
            1. Reads JSON from stdin
            2. Produces output matching the contract EXACTLY
            3. Logs to stderr as JSON
            4. Returns exit 0 on success, exit 1 on failure

            Output ONLY the Nushell script, no explanation."

            $prompt | opencode -p $in | save -f /tmp/tool.nu
            print "Generated tool saved to /tmp/tool.nu"
            '

      # 2. EXECUTE THE GENERATED TOOL
      - id: execute
        type: io.kestra.plugin.scripts.shell.Commands
        description: Run the AI-generated Nushell via run-tool.nu
        runner: PROCESS
        commands:
          - |
            nu -c '
            let run_input = {
              tool_path: "/tmp/tool.nu"
              tool_input: ({{ inputs.input_json }} | from json)
              output_path: "/tmp/output.json"
              logs_path: "/tmp/logs.json"
              context: { trace_id: "{{ execution.id }}" }
            }
            $run_input | to json | nu {{ inputs.tools_dir }}/run-tool.nu
            '

      # 3. GATE: CONTRACT VALIDATION (Law 2: Draconian validation)
      - id: gate_contract
        type: io.kestra.plugin.scripts.shell.Commands
        description: DataContract is the law - validate via validate.nu
        runner: PROCESS
        commands:
          - |
            nu -c '
            let validate_input = {
              contract_path: "{{ inputs.contract }}"
              server: "local"
              context: { trace_id: "{{ execution.id }}" }
            }
            $validate_input | to json | nu {{ inputs.tools_dir }}/validate.nu
            '

      # 4. CHECK: Did we pass?
      - id: check_pass
        type: io.kestra.plugin.core.flow.If
        condition: "{{ outputs.gate_contract.exitCode == 0 }}"
        then:
          - id: success
            type: io.kestra.plugin.core.log.Log
            message: "Contract satisfied on attempt {{ taskrun.value }}"
          - id: done
            type: io.kestra.plugin.core.execution.Exit
            state: SUCCESS

      # 5. SELF-HEAL: Collect feedback for next attempt (Law 2)
      - id: self_heal
        type: io.kestra.plugin.scripts.shell.Commands
        description: Collect feedback for AI to fix itself
        runner: PROCESS
        commands:
          - |
            nu -c '
            let output = (open /tmp/output.json | to json)
            let logs = (open /tmp/logs.json)
            let feedback = $"ATTEMPT {{ taskrun.value }} FAILED.

            CONTRACT ERRORS:
            {{ outputs.gate_contract.stdErr }}

            OUTPUT PRODUCED:
            ($output)

            LOGS:
            ($logs)

            FIX THE NUSHELL SCRIPT TO SATISFY THE CONTRACT."

            # Store feedback for next iteration
            $feedback | save -f /tmp/feedback.txt
            print $feedback
            '

      # 6. UPDATE FEEDBACK VARIABLE
      - id: update_feedback
        type: io.kestra.plugin.core.execution.SetVariables
        variables:
          feedback: "{{ read('/tmp/feedback.txt') }}"

  # 7. ESCALATE: After max attempts, page human (Law 2)
  - id: escalate
    type: io.kestra.plugin.core.log.Log
    level: ERROR
    message: |
      ESCALATION REQUIRED (Law 2)

      The AI failed to satisfy the contract after {{ inputs.max_attempts }} attempts.

      DO NOT FIX THE NUSHELL SCRIPT.
      FIX THE PROMPT OR THE CONTRACT.

      Task: {{ inputs.task }}
      Contract: {{ inputs.contract }}
      Last feedback: {{ vars.feedback }}

  - id: fail
    type: io.kestra.plugin.core.execution.Exit
    state: FAILED

outputs:
  - id: success
    type: BOOLEAN
    value: "{{ outputs.check_pass is defined }}"
  - id: attempts
    type: INT
    value: "{{ taskrun.value }}"
  - id: output_file
    type: STRING
    value: "/tmp/output.json"
