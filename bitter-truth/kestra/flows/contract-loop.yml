# bitter-truth: Contract-Driven Self-Healing Loop (CANONICAL)
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes all Nushell, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Kestra owns execution
#
# PATTERN: Generate -> Execute -> Validate -> (Pass=Exit | Fail=Feedback->Retry)

id: contract-loop
namespace: bitter

inputs:
  - id: contract
    type: STRING
    description: Path to DataContract (source of truth)
    required: true

  - id: task
    type: STRING
    description: Natural language intent (what AI should generate)
    required: true

  - id: input_json
    type: STRING
    defaults: "{}"
    description: JSON input for the generated tool

  - id: max_attempts
    type: INT
    defaults: 5
    description: Attempts before escalating to human

  - id: tools_dir
    type: STRING
    defaults: "./bitter-truth/tools"
    description: Directory containing bitter-truth tools

  - id: timeout_seconds
    type: INT
    defaults: 300
    description: Timeout for AI generation

variables:
  feedback: "Initial generation"
  trace_id: "{{ execution.id }}"
  work_dir: "/tmp/kestra/{{ execution.id }}"
  attempt_count: "0"

tasks:
  # INITIALIZATION
  - id: init
    type: io.kestra.plugin.core.log.Log
    level: INFO
    message: |
      üöÄ bitter-truth workflow starting
      Trace: {{ vars.trace_id }}
      Contract: {{ inputs.contract }}
      Task: {{ inputs.task }}
      Max Attempts: {{ inputs.max_attempts }}

  # CREATE WORKSPACE (prevents file collision)
  - id: create_workspace
    type: io.kestra.plugin.scripts.shell.Commands
    description: Create execution-specific workspace
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - mkdir -p {{ vars.work_dir }}

  # VALIDATE CONTRACT EXISTS
  - id: check_contract
    type: io.kestra.plugin.scripts.shell.Commands
    description: Validate contract file exists
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - |
        nu -c '
        if not ("{{ inputs.contract }}" | path exists) {
          print "FATAL: Contract not found: {{ inputs.contract }}"
          exit 1
        }
        print "‚úì Contract exists"
        '
    onFailure:
      - id: fail_no_contract
        type: io.kestra.plugin.core.execution.Exit
        state: FAILED

  # RETRY LOOP
  - id: attempt_loop
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ range(1, inputs.max_attempts + 1) }}"
    tasks:

      - id: log_attempt
        type: io.kestra.plugin.core.log.Log
        level: INFO
        message: "‚Üí Attempt {{ taskrun.value }}/{{ inputs.max_attempts }} (Trace: {{ vars.trace_id }})"

      # 1. GENERATE: AI generates Nushell from contract + feedback
      - id: generate_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: generate-tool-testable
        inputs:
          contract_path: "{{ inputs.contract }}"
          task: "{{ inputs.task }}"
          feedback: "{{ vars.feedback }}"
          attempt: "{{ taskrun.value }}/{{ inputs.max_attempts }}"
          output_path: "{{ vars.work_dir }}/tool.nu"
          timeout_seconds: "{{ inputs.timeout_seconds }}"
          trace_id: "{{ vars.trace_id }}"
          tools_dir: "{{ inputs.tools_dir }}"
        onFailure:
          - id: log_generate_error
            type: io.kestra.plugin.core.log.Log
            level: ERROR
            message: "Generation failed: {{ taskrun.stderr }}"

      # 2. EXECUTE: Run the generated tool
      - id: execute_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: execute-tool-testable
        inputs:
          tool_path: "{{ vars.work_dir }}/tool.nu"
          tool_input: "{{ inputs.input_json }}"
          output_path: "{{ vars.work_dir }}/output.json"
          logs_path: "{{ vars.work_dir }}/logs.json"
          trace_id: "{{ vars.trace_id }}"
          tools_dir: "{{ inputs.tools_dir }}"
          timeout_seconds: 60
        onFailure:
          - id: log_execute_error
            type: io.kestra.plugin.core.log.Log
            level: ERROR
            message: "Execution failed: {{ taskrun.stderr }}"

      # 3. VALIDATE: Contract validation
      - id: validate_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: validate-tool-testable
        inputs:
          contract_path: "{{ inputs.contract }}"
          output_path: "{{ vars.work_dir }}/output.json"
          trace_id: "{{ vars.trace_id }}"
          tools_dir: "{{ inputs.tools_dir }}"
          dry_run: false

      # 4. CHECK: Did we pass?
      - id: check_pass
        type: io.kestra.plugin.core.flow.If
        condition: |
          {% set result = outputs.validate_step.validation_result | from_json %}
          {{ result.success and result.data.valid }}
        then:
          # SUCCESS
          - id: log_success
            type: io.kestra.plugin.core.log.Log
            level: INFO
            message: "‚úì Contract satisfied on attempt {{ taskrun.value }}/{{ inputs.max_attempts }}"

          - id: success_exit
            type: io.kestra.plugin.core.execution.Exit
            state: SUCCESS

      # 5. SELF-HEAL: Collect feedback
      - id: feedback_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: collect-feedback
        inputs:
          output_file: "{{ vars.work_dir }}/output.json"
          logs_file: "{{ vars.work_dir }}/logs.json"
          validation_errors: "{{ outputs.validate_step.validation_result }}"
          attempt_number: "{{ taskrun.value }}/{{ inputs.max_attempts }}"
        onFailure:
          - id: log_feedback_error
            type: io.kestra.plugin.core.log.Log
            level: WARN
            message: "Feedback collection failed, using previous feedback"

      # 6. UPDATE: Store feedback
      - id: update_feedback
        type: io.kestra.plugin.core.execution.SetVariables
        variables:
          feedback: "{{ outputs.feedback_step.feedback }}"
          attempt_count: "{{ taskrun.value }}"

      - id: log_attempt_end
        type: io.kestra.plugin.core.log.Log
        level: INFO
        message: "‚Üê Attempt {{ taskrun.value }} failed, will retry"

  # ESCALATION: Max attempts exceeded
  - id: escalate
    type: io.kestra.plugin.core.log.Log
    level: ERROR
    message: |
      ‚ö†Ô∏è ESCALATION REQUIRED (Law 2)

      AI failed to satisfy contract after {{ inputs.max_attempts }} attempts.

      DO NOT FIX THE NUSHELL SCRIPT.
      FIX THE PROMPT OR THE CONTRACT.

      Trace: {{ vars.trace_id }}
      Task: {{ inputs.task }}
      Contract: {{ inputs.contract }}
      Last Feedback: {{ vars.feedback }}

  # CLEANUP: Always delete workspace
  - id: cleanup
    type: io.kestra.plugin.scripts.shell.Commands
    description: Clean up workspace
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - rm -rf {{ vars.work_dir }}

  - id: fail
    type: io.kestra.plugin.core.execution.Exit
    state: FAILED

outputs:
  - id: success
    type: BOOLEAN
    value: "{{ taskrun.outcomes contains('success_exit') }}"
    description: Whether workflow succeeded

  - id: output_file
    type: STRING
    value: "{{ vars.work_dir }}/output.json"
    description: Final tool output

  - id: tool_file
    type: STRING
    value: "{{ vars.work_dir }}/tool.nu"
    description: Final generated tool

  - id: trace_id
    type: STRING
    value: "{{ vars.trace_id }}"
    description: Workflow trace ID

  - id: attempts_made
    type: INT
    value: "{{ vars.attempt_count | int }}"
    description: Number of attempts before success/failure
