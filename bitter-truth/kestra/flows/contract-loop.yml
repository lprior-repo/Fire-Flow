# bitter-truth: Contract-Driven Self-Healing Loop (CANONICAL)
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes all Nushell, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Kestra owns execution
#
# PATTERN: Generate -> Execute -> Validate -> (Pass=Exit | Fail=Feedback->Retry)

id: contract-loop
namespace: bitter

inputs:
  - id: contract
    type: STRING
    description: Path to DataContract (source of truth)
    required: true

  - id: task
    type: STRING
    description: Natural language intent (what AI should generate)
    required: true

  - id: input_json
    type: STRING
    defaults: "{}"
    description: JSON input for the generated tool

  - id: max_attempts
    type: INT
    defaults: 5
    description: Attempts before escalating to human

  - id: tools_dir
    type: STRING
    defaults: "./bitter-truth/tools"
    description: Directory containing bitter-truth tools

  # TIMEOUT HIERARCHY (P1-2)
  - id: workflow_timeout_seconds
    type: INT
    defaults: 3600
    description: Maximum workflow duration (1 hour default)

  - id: generate_timeout_seconds
    type: INT
    defaults: 900
    description: Timeout for AI generation (15 min default)

  - id: execute_timeout_seconds
    type: INT
    defaults: 300
    description: Timeout for tool execution (5 min default)

  - id: validate_timeout_seconds
    type: INT
    defaults: 60
    description: Timeout for validation (1 min default)

variables:
  feedback: "Initial generation"
  trace_id: "{{ execution.id }}"
  work_dir: "/tmp/kestra/{{ execution.id }}"
  attempt_count: "0"

tasks:
  # INITIALIZATION
  - id: init
    type: io.kestra.plugin.core.log.Log
    level: INFO
    message: |
      üöÄ bitter-truth workflow starting
      Trace: {{ vars.trace_id }}
      Contract: {{ inputs.contract }}
      Task: {{ inputs.task }}
      Max Attempts: {{ inputs.max_attempts }}

  # CREATE WORKSPACE (prevents file collision)
  - id: create_workspace
    type: io.kestra.plugin.scripts.shell.Commands
    description: Create execution-specific workspace
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - mkdir -p {{ vars.work_dir }}

  # VALIDATE CONTRACT EXISTS
  - id: check_contract
    type: io.kestra.plugin.scripts.shell.Commands
    description: Validate contract file exists
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - |
        nu -c '
        if not ("{{ inputs.contract }}" | path exists) {
          print "FATAL: Contract not found: {{ inputs.contract }}"
          exit 1
        }
        print "‚úì Contract exists"
        '
    onFailure:
      - id: fail_no_contract
        type: io.kestra.plugin.core.execution.Exit
        state: FAILED

  # VALIDATE TIMEOUT HIERARCHY (P1-2)
  - id: validate_timeouts
    type: io.kestra.plugin.scripts.shell.Commands
    description: Ensure workflow timeout exceeds sum of child timeouts
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - |
        nu -c '
        let workflow = {{ inputs.workflow_timeout_seconds }}
        let per_attempt = {{ inputs.generate_timeout_seconds }} + {{ inputs.execute_timeout_seconds }} + {{ inputs.validate_timeout_seconds }}
        let total_needed = $per_attempt * {{ inputs.max_attempts }}
        let buffer = ($total_needed * 0.1) | math round  # 10% buffer
        let minimum = $total_needed + $buffer

        if $workflow < $minimum {
          print $"ERROR: workflow_timeout \(($workflow)s\) < needed \(($minimum)s = ($total_needed)s + ($buffer)s buffer\)"
          print $"Increase workflow_timeout_seconds to at least ($minimum)"
          exit 1
        }

        print $"‚úì Timeout hierarchy valid: workflow=($workflow)s >= needed=($minimum)s"
        '
    onFailure:
      - id: fail_timeout_invalid
        type: io.kestra.plugin.core.execution.Exit
        state: FAILED

  # RETRY LOOP
  # CRITICAL: concurrencyLimit=1 ensures sequential attempts (not parallel)
  # Without this, all attempts run simultaneously, causing heap exhaustion
  - id: attempt_loop
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ range(1, inputs.max_attempts + 1) }}"
    concurrencyLimit: 1
    tasks:

      - id: log_attempt
        type: io.kestra.plugin.core.log.Log
        level: INFO
        message: "‚Üí Attempt {{ taskrun.value }}/{{ inputs.max_attempts }} (Trace: {{ vars.trace_id }})"

      # EXPONENTIAL BACKOFF: Wait before retry (P1-1)
      - id: wait_before_retry
        type: io.kestra.plugin.core.flow.If
        condition: "{{ taskrun.value > 1 }}"  # Skip on first attempt
        then:
          - id: backoff_delay
            type: io.kestra.plugin.core.flow.Sleep
            duration: "PT{{ 2 ** (taskrun.value - 2) }}S"  # 1s, 2s, 4s, 8s, 16s
          - id: log_backoff
            type: io.kestra.plugin.core.log.Log
            level: INFO
            message: "Waited {{ 2 ** (taskrun.value - 2) }}s before retry (exponential backoff)"

      # 1. GENERATE: AI generates Nushell from contract + feedback
      - id: generate_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: generate-tool-testable
        inputs:
          contract_path: "{{ inputs.contract }}"
          task: "{{ inputs.task }}"
          feedback: "{{ vars.feedback }}"
          attempt: "{{ taskrun.value }}/{{ inputs.max_attempts }}"
          output_path: "{{ vars.work_dir }}/tool.nu"
          timeout_seconds: "{{ inputs.generate_timeout_seconds }}"
          trace_id: "{{ vars.trace_id }}"
          tools_dir: "{{ inputs.tools_dir }}"
        onFailure:
          - id: log_generate_error
            type: io.kestra.plugin.core.log.Log
            level: ERROR
            message: "Generation failed: {{ taskrun.stderr }}"

      # TOOL DEDUPLICATION: Cache by hash (Jevons Paradox - prevent duplicates)
      - id: deduplicate_tool
        type: io.kestra.plugin.scripts.shell.Commands
        description: Cache generated tool by content hash to prevent duplicates
        taskRunner:
          type: io.kestra.plugin.core.runner.Process
        commands:
          - |
            nu -c '
            let tool_path = "{{ vars.work_dir }}/tool.nu"
            let tool_hash = (open $tool_path | hash sha256)
            let cache_dir = "/var/cache/kestra/tools"
            let cached_tool = $"($cache_dir)/($tool_hash).nu"

            # Create cache directory if needed
            mkdir -p $cache_dir

            # Check if identical tool already exists
            if ($cached_tool | path exists) {
              print $"‚ôªÔ∏è Reusing cached tool \(hash: ($tool_hash)\)"
              cp $cached_tool $tool_path
            } else {
              print $"üíæ Caching new tool \(hash: ($tool_hash)\)"
              cp $tool_path $cached_tool
            }
            '

      # 2. EXECUTE: Run the generated tool
      - id: execute_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: execute-tool-testable
        inputs:
          tool_path: "{{ vars.work_dir }}/tool.nu"
          tool_input: "{{ inputs.input_json }}"
          output_path: "{{ vars.work_dir }}/output.json"
          logs_path: "{{ vars.work_dir }}/logs.json"
          trace_id: "{{ vars.trace_id }}"
          tools_dir: "{{ inputs.tools_dir }}"
          timeout_seconds: "{{ inputs.execute_timeout_seconds }}"
        onFailure:
          - id: log_execute_error
            type: io.kestra.plugin.core.log.Log
            level: ERROR
            message: "Execution failed: {{ taskrun.stderr }}"

      # 3. VALIDATE: Contract validation
      - id: validate_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: validate-tool-testable
        inputs:
          contract_path: "{{ inputs.contract }}"
          output_path: "{{ vars.work_dir }}/output.json"
          trace_id: "{{ vars.trace_id }}"
          tools_dir: "{{ inputs.tools_dir }}"
          dry_run: false

      # 4. CHECK: Did we pass?
      # FIX: Use fromJson() function (not | from_json filter which doesn't exist in Pebble)
      - id: check_pass
        type: io.kestra.plugin.core.flow.If
        condition: "{{ fromJson(outputs.validate_step.validation_result).success and fromJson(outputs.validate_step.validation_result).data.valid }}"
        then:
          # SUCCESS
          - id: log_success
            type: io.kestra.plugin.core.log.Log
            level: INFO
            message: "‚úì Contract satisfied on attempt {{ taskrun.value }}/{{ inputs.max_attempts }}"

          - id: success_exit
            type: io.kestra.plugin.core.execution.Exit
            state: SUCCESS

      # 5. SELF-HEAL: Collect feedback
      - id: feedback_step
        type: io.kestra.plugin.core.flow.Subflow
        namespace: bitter
        flowId: collect-feedback
        inputs:
          output_file: "{{ vars.work_dir }}/output.json"
          logs_file: "{{ vars.work_dir }}/logs.json"
          validation_errors: "{{ outputs.validate_step.validation_result }}"
          attempt_number: "{{ taskrun.value }}/{{ inputs.max_attempts }}"
        onFailure:
          - id: log_feedback_error
            type: io.kestra.plugin.core.log.Log
            level: WARN
            message: "Feedback collection failed, using previous feedback"

      # 6. UPDATE: Store feedback
      - id: update_feedback
        type: io.kestra.plugin.core.execution.SetVariables
        variables:
          feedback: "{{ outputs.feedback_step.feedback }}"
          attempt_count: "{{ taskrun.value }}"

      - id: log_attempt_end
        type: io.kestra.plugin.core.log.Log
        level: INFO
        message: "‚Üê Attempt {{ taskrun.value }} failed, will retry"

  # ESCALATION: Max attempts exceeded
  - id: escalate
    type: io.kestra.plugin.core.log.Log
    level: ERROR
    message: |
      ‚ö†Ô∏è ESCALATION REQUIRED (Law 2)

      AI failed to satisfy contract after {{ inputs.max_attempts }} attempts.

      DO NOT FIX THE NUSHELL SCRIPT.
      FIX THE PROMPT OR THE CONTRACT.

      Trace: {{ vars.trace_id }}
      Task: {{ inputs.task }}
      Contract: {{ inputs.contract }}
      Last Feedback: {{ vars.feedback }}

  # CLEANUP: Always delete workspace
  - id: cleanup
    type: io.kestra.plugin.scripts.shell.Commands
    description: Clean up workspace
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - rm -rf {{ vars.work_dir }}

  # AUTO-CLEANUP: Delete old artifacts (Jevons Paradox - prevent accumulation)
  - id: cleanup_old_artifacts
    type: io.kestra.plugin.scripts.shell.Commands
    description: Delete artifacts older than 7 days to prevent disk exhaustion
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - |
        nu -c '
        # Clean old execution workspaces (> 7 days)
        if ("/tmp/kestra" | path exists) {
          let old_workspaces = (ls /tmp/kestra -s | where modified < ((date now) - 7day) | get name)
          if ($old_workspaces | length) > 0 {
            $old_workspaces | each { |dir| rm -rf $dir }
            print $"üóëÔ∏è Cleaned ($old_workspaces | length) old workspaces"
          }
        }

        # Clean old generated tools (> 7 days)
        if ("/tmp/generated-tools" | path exists) {
          let old_tools = (ls /tmp/generated-tools -s | where modified < ((date now) - 7day) | get name)
          if ($old_tools | length) > 0 {
            $old_tools | each { |file| rm -f $file }
            print $"üóëÔ∏è Cleaned ($old_tools | length) old generated tools"
          }
        }

        # Clean old cache (> 30 days, keep longer)
        if ("/var/cache/kestra/tools" | path exists) {
          let old_cache = (ls /var/cache/kestra/tools -s | where modified < ((date now) - 30day) | get name)
          if ($old_cache | length) > 0 {
            $old_cache | each { |file| rm -f $file }
            print $"üóëÔ∏è Cleaned ($old_cache | length) old cache entries"
          }
        }

        print "‚úì Artifact cleanup complete"
        '

  - id: fail
    type: io.kestra.plugin.core.execution.Exit
    state: FAILED

outputs:
  - id: success
    type: BOOLEAN
    value: "{{ taskrun.outcomes contains('success_exit') }}"
    description: Whether workflow succeeded

  - id: output_file
    type: STRING
    value: "{{ vars.work_dir }}/output.json"
    description: Final tool output

  - id: tool_file
    type: STRING
    value: "{{ vars.work_dir }}/tool.nu"
    description: Final generated tool

  - id: trace_id
    type: STRING
    value: "{{ vars.trace_id }}"
    description: Workflow trace ID

  - id: attempts_made
    type: INT
    value: "{{ vars.attempt_count | int }}"
    description: Number of attempts before success/failure
