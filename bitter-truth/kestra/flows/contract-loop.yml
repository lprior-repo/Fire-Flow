# bitter-truth: Contract-Driven Loop with Self-Healing
#
# THE 4 LAWS:
# 1. No-Human Zone: AI writes all Nushell, humans write contracts
# 2. Contract is Law: Validation is draconian, self-heal on failure
# 3. We Set the Standard: Human defines target, AI hits it
# 4. Orchestrator Runs Everything: Kestra owns execution
#
# THE PATTERN:
# Generate -> Gate -> Pass or Self-Heal -> Escalate after N failures
#
# REQUIREMENTS:
# - nushell (nu) installed and in PATH
# - datacontract-cli installed
# - opencode CLI for AI generation

id: contract-loop
namespace: bitter

inputs:
  - id: contract
    type: STRING
    description: Path to DataContract (source of truth)

  - id: task
    type: STRING
    description: Natural language intent (what AI should generate)

  - id: input_json
    type: STRING
    defaults: "{}"
    description: JSON input for the generated tool

  - id: max_attempts
    type: INT
    defaults: 5
    description: Attempts before escalating to human (to fix PROMPT, not code)

  - id: tools_dir
    type: STRING
    defaults: "./bitter-truth/tools"
    description: Directory containing bitter-truth tools

variables:
  feedback: "Initial generation"

tasks:
  # LOOP: Generate -> Validate -> Self-Heal or Escalate
  - id: loop
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ range(1, inputs.max_attempts + 1) }}"
    tasks:

      # 1. AI GENERATES NUSHELL (Law 1: AI is exclusive author)
      # Uses generate.nu tool with timeout to prevent orphaned processes
      - id: generate
        type: io.kestra.plugin.scripts.shell.Commands
        description: AI compiles intent -> Nushell via generate.nu
        runner: PROCESS
        timeout: PT10M
        env:
          XDG_DATA_HOME: "/tmp"
          XDG_CONFIG_HOME: "/tmp"
          HOME: "/tmp"
        commands:
          - |
            nu -c '
            let gen_input = {
              contract_path: "{{ inputs.contract }}"
              task: "{{ inputs.task }}"
              feedback: "{{ vars.feedback }}"
              attempt: "{{ taskrun.value }}/{{ inputs.max_attempts }}"
              output_path: "/tmp/tool.nu"
              context: {
                trace_id: "{{ execution.id }}"
                timeout_seconds: 300
              }
            }
            $gen_input | to json | nu {{ inputs.tools_dir }}/generate.nu
            '

      # 2. EXECUTE THE GENERATED TOOL
      - id: execute
        type: io.kestra.plugin.scripts.shell.Commands
        description: Run the AI-generated Nushell via run-tool.nu
        runner: PROCESS
        commands:
          - |
            nu -c '
            let input_json_str = "{{ inputs.input_json }}"
            let run_input = {
              tool_path: "/tmp/tool.nu"
              tool_input: ($input_json_str | from json)
              output_path: "/tmp/output.json"
              logs_path: "/tmp/logs.json"
              context: { trace_id: "{{ execution.id }}" }
            }
            $run_input | to json | nu {{ inputs.tools_dir }}/run-tool.nu
            '

      # 3. GATE: CONTRACT VALIDATION (Law 2: Draconian validation)
      - id: gate_contract
        type: io.kestra.plugin.scripts.shell.Commands
        description: DataContract is the law - validate via validate.nu
        runner: PROCESS
        commands:
          - |
            nu -c '
            let validate_input = {
              contract_path: "{{ inputs.contract }}"
              server: "local"
              context: { trace_id: "{{ execution.id }}" }
            }
            $validate_input | to json | nu {{ inputs.tools_dir }}/validate.nu
            '

      # 4. CHECK: Did we pass?
      - id: check_pass
        type: io.kestra.plugin.core.flow.If
        condition: "{{ outputs.gate_contract.exitCode == 0 }}"
        then:
          - id: success
            type: io.kestra.plugin.core.log.Log
            message: "Contract satisfied on attempt {{ taskrun.value }}"
          - id: done
            type: io.kestra.plugin.core.execution.Exit
            state: SUCCESS

      # 5. SELF-HEAL: Collect feedback for next attempt (Law 2)
      - id: self_heal
        type: io.kestra.plugin.scripts.shell.Commands
        description: Collect feedback for AI to fix itself
        runner: PROCESS
        commands:
          - |
            nu -c '
            let output = (open /tmp/output.json | to json)
            let logs = (open /tmp/logs.json)
            let attempt = "{{ taskrun.value }}"
            let contract_errors = "{{ outputs.gate_contract.stdErr }}"

            # Build feedback without template/interpolation conflicts
            let feedback = [
              $"ATTEMPT ($attempt) FAILED."
              ""
              "CONTRACT ERRORS:"
              $contract_errors
              ""
              "OUTPUT PRODUCED:"
              $output
              ""
              "LOGS:"
              ($logs | to text)
              ""
              "FIX THE NUSHELL SCRIPT TO SATISFY THE CONTRACT."
            ] | str join "\n"

            # Store feedback for next iteration
            $feedback | save -f /tmp/feedback.txt
            print $feedback
            '

      # 6. UPDATE FEEDBACK VARIABLE
      - id: update_feedback
        type: io.kestra.plugin.core.execution.SetVariables
        variables:
          feedback: "{{ read('/tmp/feedback.txt') }}"

  # 7. ESCALATE: After max attempts, page human (Law 2)
  - id: escalate
    type: io.kestra.plugin.core.log.Log
    level: ERROR
    message: |
      ESCALATION REQUIRED (Law 2)

      The AI failed to satisfy the contract after {{ inputs.max_attempts }} attempts.

      DO NOT FIX THE NUSHELL SCRIPT.
      FIX THE PROMPT OR THE CONTRACT.

      Task: {{ inputs.task }}
      Contract: {{ inputs.contract }}
      Last feedback: {{ vars.feedback }}

  - id: fail
    type: io.kestra.plugin.core.execution.Exit
    state: FAILED

outputs:
  - id: success
    type: BOOLEAN
    value: "{{ outputs.check_pass is defined }}"
  - id: output_file
    type: STRING
    value: "/tmp/output.json"
