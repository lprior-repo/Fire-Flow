# Modular Component: AI Generates Nushell Tool from Contract
# TESTABLE VERSION with input validation, error handling, and observability
#
# INPUT: contract_path, task, feedback, attempt, tools_dir, trace_id
# OUTPUT: tool_path, validation_status, error_message (if failed)
# TESTED: Input validation, error paths, output schema
#
# Pattern: Validate Input -> Execute -> Validate Output -> Return Result

id: generate-tool-testable
namespace: bitter
description: AI generates Nushell tool from DataContract + task description (testable)

inputs:
  - id: contract_path
    type: STRING
    description: Path to DataContract YAML file
    required: true

  - id: task
    type: STRING
    description: Natural language description of what to generate
    required: true

  - id: feedback
    type: STRING
    defaults: "Initial generation"
    description: Feedback from previous failed attempt (for self-healing)

  - id: attempt
    type: STRING
    defaults: "1/5"
    description: Current attempt number (e.g., "2/5")

  - id: tools_dir
    type: STRING
    defaults: "./bitter-truth/tools"
    description: Directory containing bitter-truth tools

  - id: output_path
    type: STRING
    defaults: "/tmp/tool.nu"
    description: Where to save generated tool

  - id: timeout_seconds
    type: INT
    defaults: 300
    description: Timeout for AI generation

  - id: trace_id
    type: STRING
    defaults: ""
    description: Trace ID for logging

tasks:
  # STEP 1: VALIDATE INPUTS (fail early)
  - id: validate_inputs
    type: io.kestra.plugin.scripts.shell.Commands
    description: Validate required inputs exist and are valid
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - |
        nu -c '
        mut errors = []

        # Check contract exists
        if not ("{{ inputs.contract_path }}" | path exists) {
          $errors = ($errors | append ["Contract file not found: {{ inputs.contract_path }}"])
        }

        # Check task is not empty
        if ("{{ inputs.task }}" | is-empty) {
          $errors = ($errors | append ["Task description is required"])
        }

        # Check tools_dir exists
        if not ("{{ inputs.tools_dir }}" | path exists) {
          $errors = ($errors | append ["Tools directory not found: {{ inputs.tools_dir }}"])
        }

        if ($errors | length) > 0 {
          let error_msg = ($errors | str join " | ")
          { level: "error", msg: $error_msg, trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e
          print { success: false, error: $error_msg, trace_id: "{{ inputs.trace_id }}", validated: false } | to json
          exit 1
        } else {
          { level: "info", msg: "Input validation passed", trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e
          print { success: true, validated: true, trace_id: "{{ inputs.trace_id }}" } | to json
          exit 0
        }
        '

  # STEP 2: GENERATE
  - id: generate_code
    type: io.kestra.plugin.scripts.shell.Commands
    description: AI generates Nushell via opencode
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    timeout: PT10M
    env:
      XDG_DATA_HOME: /tmp/opencode-data
      XDG_CACHE_HOME: /tmp/opencode-cache
      XDG_STATE_HOME: /tmp/opencode-state
      MODEL: local/qwen3-coder
    commands:
      - |
        nu -c '
        # Call opencode to generate code
        { level: "info", msg: "Calling opencode for code generation", trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e

        let gen_input = {
          contract_path: "{{ inputs.contract_path }}"
          task: "{{ inputs.task }}"
          feedback: "{{ inputs.feedback }}"
          attempt: "{{ inputs.attempt }}"
          output_path: "{{ inputs.output_path }}"
          context: {
            trace_id: "{{ inputs.trace_id }}"
            timeout_seconds: {{ inputs.timeout_seconds }}
          }
        }

        let result = do {
          $gen_input | to json | nu {{ inputs.tools_dir }}/generate.nu
        } | complete

        if $result.exit_code != 0 {
          { level: "error", msg: "Code generation failed", exit_code: $result.exit_code, trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e
          print { success: false, error: "Code generation failed", trace_id: "{{ inputs.trace_id }}" } | to json
          exit 1
        } else {
          let response = $result.stdout | from json
          print $response | to json
          exit 0
        }
        '

  # STEP 3: VALIDATE OUTPUT (generated tool is valid Nushell)
  - id: validate_output
    type: io.kestra.plugin.scripts.shell.Commands
    description: Validate generated tool is valid Nushell syntax
    taskRunner:
      type: io.kestra.plugin.core.runner.Process
    commands:
      - |
        nu -c '
        let tool_path = "{{ inputs.output_path }}"

        if not ($tool_path | path exists) {
          { level: "error", msg: "Generated tool not found", path: $tool_path, trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e
          print { success: false, error: "Tool not created", trace_id: "{{ inputs.trace_id }}" } | to json
          exit 1
        }

        # Try to parse the tool to check for syntax errors
        let syntax_check = do {
          nu -c $"check ($tool_path | open --raw)"
        } | complete

        if $syntax_check.exit_code != 0 {
          { level: "error", msg: "Generated tool has syntax errors", path: $tool_path, trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e
          print { success: false, error: "Tool syntax invalid", trace_id: "{{ inputs.trace_id }}" } | to json
          exit 1
        }

        { level: "info", msg: "Generated tool validated", path: $tool_path, trace_id: "{{ inputs.trace_id }}" } | to json -r | print -e
        print { success: true, tool_path: $tool_path, validated: true, trace_id: "{{ inputs.trace_id }}" } | to json
        '

outputs:
  - id: tool_path
    type: STRING
    value: "{{ inputs.output_path }}"
    description: Path to generated tool

  - id: trace_id
    type: STRING
    value: "{{ inputs.trace_id }}"
    description: Trace ID for observability
