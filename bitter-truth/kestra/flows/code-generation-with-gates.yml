# Contract-Driven Code Generation with Quality Gates
#
# The bitter-truth pattern:
# 1. Data Contract defines what success looks like
# 2. AI generates code (non-deterministic)
# 3. Deterministic validation gates
# 4. Loop with structured feedback until all gates pass
#
# The orchestrator owns the process. AI is just a worker.

id: code-generation
namespace: bitter.ai

description: |
  Contract-driven code generation with quality gates.
  Data Contract CLI validates schemas. Nushell runs tools.

inputs:
  - id: task_description
    type: STRING
    description: What the code should do

  - id: language
    type: STRING
    defaults: nushell
    description: Target language

  - id: contract_path
    type: STRING
    description: Path to the data contract that defines success

  - id: coverage_threshold
    type: INT
    defaults: 80
    description: Minimum test coverage percentage

  - id: max_attempts
    type: INT
    defaults: 5
    description: Maximum generation attempts

tasks:
  # Step 1: Load and parse contract
  - id: load_contract
    type: io.kestra.plugin.scripts.shell.Commands
    description: Load the data contract that defines success criteria
    commands:
      - |
        # Parse contract to extract requirements
        cat {{ inputs.contract_path }} | nu -c '
          $in | from yaml | to json
        ' > /tmp/contract.json

        echo "Contract loaded: {{ inputs.contract_path }}"

  # Step 2: Generation Loop
  - id: generation_loop
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ range(1, inputs.max_attempts + 1) }}"
    tasks:
      # 2a: AI generates code
      - id: generate
        type: io.kestra.plugin.scripts.shell.Commands
        description: AI generates code based on contract + feedback
        commands:
          - |
            PROMPT="Generate {{ inputs.language }} code that:
            {{ inputs.task_description }}

            Must satisfy contract: {{ inputs.contract_path }}
            Attempt: {{ taskrun.value }} of {{ inputs.max_attempts }}"

            # Call OpenCode
            # opencode -p "$PROMPT" -f json > /tmp/generated.json
            echo "AI would generate here"

      # 2b: GATE 1 - Contract validation (deterministic)
      - id: gate_contract
        type: io.kestra.plugin.scripts.shell.Commands
        description: Validate output against data contract
        commands:
          - |
            echo "Gate 1: Contract validation"
            # datacontract test {{ inputs.contract_path }} --data /tmp/output.json
            echo '{"passed": true, "gate": "contract"}'

      # 2c: GATE 2 - Tests pass (deterministic)
      - id: gate_tests
        type: io.kestra.plugin.scripts.shell.Commands
        description: Run tests
        commands:
          - |
            echo "Gate 2: Tests"
            # nu test.nu
            echo '{"passed": true, "gate": "tests"}'

      # 2d: GATE 3 - Coverage threshold (deterministic)
      - id: gate_coverage
        type: io.kestra.plugin.scripts.shell.Commands
        description: Check coverage meets threshold
        commands:
          - |
            echo "Gate 3: Coverage >= {{ inputs.coverage_threshold }}%"
            COVERAGE=85
            THRESHOLD={{ inputs.coverage_threshold }}

            if [ $COVERAGE -ge $THRESHOLD ]; then
              echo '{"passed": true, "gate": "coverage", "actual": '$COVERAGE'}'
            else
              echo '{"passed": false, "gate": "coverage", "actual": '$COVERAGE'}'
              exit 1
            fi

      # 2e: Check if all gates passed
      - id: check_gates
        type: io.kestra.plugin.core.flow.If
        condition: "{{ outputs.gate_contract.exitCode == 0 and outputs.gate_tests.exitCode == 0 and outputs.gate_coverage.exitCode == 0 }}"
        then:
          - id: success
            type: io.kestra.plugin.core.flow.End
            state: SUCCESS

  # Step 3: Final output
  - id: output
    type: io.kestra.plugin.core.flow.Output
    values:
      success: true
      contract: "{{ inputs.contract_path }}"
